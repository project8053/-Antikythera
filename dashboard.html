<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Dashboard</title>
    <script src="./jquery-2.1.1.min.js"></script>
    <script>
        var beep = new Audio('beep.wav');
    </script>
    <style>
        th {
            border-right: 1px solid #C8EFEA;
            border-bottom: 1px solid #C8EFEA;
            color: #FFFFFF;
            background-color: #25B3A2;
        }

        th.sort {
            cursor: ns-resize;
        }

        td {
            border-right: 1px solid #C8EFEA;
            border-bottom: 1px solid #C8EFEA;
            color: #1C355D;
            background-color: #F8F8E4;
        }

        td.no-border {
            border-right: 0px none #000000;
            border-bottom: 0px none #000000;
            background-color: rgba(0, 0, 0, 0);
        }

        div {
            margin-bottom: 10px;
        }

        a:link {
            text-decoration: none;
            color: #1C355D;
        }

        a:visited {
            text-decoration: none;
            color: #1C355D;
        }

        a:hover {
            text-decoration: none;
            color: #25B3A2;
        }

        a:active {
            text-decoration: none;
            color: #25B3A2;
        }
    </style>
</head>
<body style="width:2100px">
    <script>
        var CONTENT_TYPE = {
            'GOOGL_INITIALIZE': 1,
            'GOOGL_SETUP_DATA': 2,
            'GOOGL_POST_LTP': 3,
            'RELGR_INITIALIZE': 4,
            'RELGR_PROCESS_ORDER': 5,
            'RELGR_ORDER_EXECUTED': 6,
        };

        var STATE = {
            'OPEN': 1,
            'CLOSE': 0,
        };

        var TREND = {
            'NONE': 0,
            'BULL': 1,
            'BEAR': 2,
        };

        var STYLE = {
            'PERCENT': parseInt('000001', 2),
            'PERMILLE': parseInt('000010', 2),
            'DEGREE': parseInt('000100', 2),
            'REDUCED': parseInt('001000', 2),
            'GRAY': parseInt('010000', 2),
            'COMMA': parseInt('100000', 2),
        };

        var SORT = {
            'SYMBOL_NAME': 1,
            'LTP_CHANGE': 2,
            'NO_OF_TRADES': 3,
            'C2O_CHANGE': 4,
            'TREND_STRENGTH': 5,
            'SLOPE_ANGLE': 6,
        };

        var SETTING = {
            'DO_SOMETHING_RETRY_INTERVAL': 5 * 1000,
            'CHECK_OPEN_RETRY_INTERVAL': 5 * 1000,
            'PRIOR_DATE_STATUS_RETRY_INTERVAL': 5 * 1000,
            'STUDIES_CALC_INTERVAL': 2 * 60 * 1000,
            'CHECK_START_STATE_INTERVAL': 1.5 * 1000,
            'CHECK_START_STATE_INIT_TIMEOUT': 10 * 60 * 1000,
            'ADX_STEP_1_PERIOD': 14,
            'ADX_STEP_2_PERIOD': 14,
            'DISPLAY_NORMALIZE_RATIO': 30 / 0.02,
            'SLOPE_NORMALIZE_RATIO': 30 / 0.01,
            'PSAR_INCR_ACC_FACTOR': 0.01,
            'EVAL_MAX_SLOPE_ANGLE': Math.PI / 4,
            'EVAL_MIN_SLOPE_ANGLE': Math.PI / 8,
            'EVAL_MAX_SLOPE_DEVIATION': 0.004,
            'MIN_LTP_CONSIDERED': 83.33,
            'MAX_LTP_CONSIDERED': 2083.33,
        };

        var marketSpeculativeOpenTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 9, 14);
        var marketCloseTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 15, 30);
        var startStatePollEndTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 9, 55);
        var evaluateScripsStartTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 11, 0);
        var evaluateScripsEndTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 14, 0);
        // 26-05-2015 - For Open Range Breakout calculation
        var openRangeCalculateTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 10, 30);

        Number.prototype.toStyle = function (style, points) {
            var fontSize = style & STYLE.REDUCED ? ';font-size: 9px' : '';
            var color = style & STYLE.GRAY ? 'color: #A9A9A9' : (this > 0 ? 'color: #093' : (this < 0 ? 'color: #D14836' : 'color: #A9A9A9'));
            var value = Math.abs(style & STYLE.PERCENT ? this * 100 : (style & STYLE.PERMILLE ? this * 1000 : this)).toFixed(points == undefined ? 2 : points);
            var suffix = style & STYLE.PERCENT ? '%' : (style & STYLE.PERMILLE ? '&permil;' : (style & STYLE.DEGREE ? '&deg;' : ''));
            return '<span style="' + color + fontSize + '">' + value + suffix + '</span>';
        };

        Number.prototype.toComma = function (points) {
            return this.toFixed(points == undefined ? 0 : Math.min(3, points)).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        };

        String.prototype.URL = function () { 
            return this + (this.indexOf('?') != -1 ? '&' : '?') + '_=' + new Date().getTime(); 
        };

        var deferGetStartState;
        var dataPendingStartState = [];
        GetStartState = function () {
            if (dataPendingStartState.length > 0) {
                var k = dataPendingStartState.shift();
                $.ajax({
                    url: 'scrip-highlights.php?symbol=' + data[k].symbol + '&ts=' + new Date().getTime(),
                    type: 'POST',
                    success: function (result) {
                        if (result.error != undefined) {
                            console.error(result.error);
                            dataPendingStartState.push(k);
                            // Sometimes, a scrip might be suspended; hence, the data will always be for prior date
                            // Stop checking once threshold is crossed
                            if (new Date() < startStatePollEndTime)
                                deferGetStartState = setTimeout(GetStartState, SETTING.CHECK_START_STATE_INTERVAL);
                            return;
                        }

                        data[k].limits.previousClosePrice = result.previousClosePrice;
                        data[k].limits.openPrice = result.openPrice;
                        deferGetStartState = setTimeout(GetStartState, SETTING.CHECK_START_STATE_INTERVAL);
                    },
                    error: function (HttpRequest, textStatus, errorThrown) {
                        console.error(HttpRequest, textStatus, errorThrown);
                        dataPendingStartState.push(k);
                        deferGetStartState = setTimeout(GetStartState, SETTING.CHECK_START_STATE_INTERVAL);
                    }
                });
            }
            else if (new Date() < startStatePollEndTime)
                deferGetStartState = setTimeout(GetStartState, SETTING.CHECK_START_STATE_INTERVAL);
        };

        var connected = false;
        // connected to religare window
        ProcessMessage = function (event) {
            switch (event.data.type) {
                case CONTENT_TYPE.GOOGL_INITIALIZE:
                    var symbol = [];
                    for (var k = 0; k < data.length; k++)
                        symbol.push(data[k].symbol);
                    google.postMessage({
                        'type': CONTENT_TYPE.GOOGL_SETUP_DATA,
                        'symbol': symbol,
                    }, '*');
                    var td = document.getElementById('state_google');
                    td.style.color = '#093';
                    td.innerHTML = 'ON';
                    break;

                case CONTENT_TYPE.GOOGL_POST_LTP:
                    if (state == STATE.OPEN)
                        // No possibility of previous close being mistaken for today's LTP as Google never posts the first LTP it encounters
                        UpdateLTP(event.data.k, event.data.LTP);
                    break;

                case CONTENT_TYPE.RELGR_INITIALIZE:
                    religare = event.source;
                    connected = true;
                    var td = document.getElementById('state_religare');
                    td.style.color = '#093';
                    td.innerHTML = 'ON';
                    break;

                case CONTENT_TYPE.RELGR_ORDER_EXECUTED:
                    break;
            }
        };

        ProcessOrder = function (k, details) {
            if (!connected)
                console.error('Religare is offline');
            else {
                details['SecurityID'] = data[k].symbol;
                details['TradingSymbol'] = data[k].securitySymbol;
                details['Series'] = data[k].securitySeries;

                religare.postMessage({
                    'type': CONTENT_TYPE.RELGR_PROCESS_ORDER,
                    'details': details,
                }, '*');
            }
        };

        UpdateLTP = function (k, LTP) {
            data[k].LTP.push(LTP);
            if (document.getElementById('ltp_' + k) != null) {
                var msg = LTP + '<br>';
                if (data[k].limits.previousClosePrice != undefined)
                    msg += ((LTP - data[k].limits.previousClosePrice) / data[k].limits.previousClosePrice).toStyle(STYLE.PERCENT);
                else
                    msg += '-';
                document.getElementById('ltp_' + k).innerHTML = msg;
            }
        };

        UpdateLayout = function () {
            try {
                for (var k = 0; k < data.length; k++) {
                    if (document.getElementById('quote_' + k) == null) {
                        var noRows = document.getElementById('quote_no_rows');
                        if (noRows != null)
                            noRows.parentNode.removeChild(noRows);
                        var row = document.createElement('tr');
                        row.id = 'quote_' + k;
                        row.innerHTML = '<td style="text-align:left;"><a href="https://www.google.com/finance?q=BOM%3A' + data[k].symbol + '" target="_blank">' + data[k].securitySymbol + '</a><br>#' + k + '</td><td id="ltp_' + k + '">-<br>-</td><td><canvas id="chart_' + k + '" height="30" width="200"></canvas></td><td id="trades_' + k + '">-</td><td id="ohlc_' + k + '"></td><td><canvas id="trend_' + k + '" height="30" width="200"></canvas></td><td id="adx_' + k + '"></td><td><canvas id="slope_' + k + '" height="30" width="200"></canvas></td><td id="angle_' + k + '">-</td>';
                        document.getElementById('quote_container').appendChild(row);
                    }

                    if (data[k].range.length == 0)
                        continue;

                    var highPrice = data[k].limits.highPrice;
                    var lowPrice = data[k].limits.lowPrice;
                    document.getElementById('ohlc_' + k).innerHTML = ((data[k].range[data[k].range.length - 1].closePrice - data[k].range[0].openPrice) / data[k].range[0].openPrice).toStyle(STYLE.PERCENT) + '<br>' + ((highPrice - lowPrice) / lowPrice).toStyle(STYLE.PERCENT | STYLE.GRAY | STYLE.REDUCED);

                    var canvas = document.getElementById('chart_' + k);
                    var context = canvas.getContext('2d');

                    if (data[k].limits.previousClosePrice != undefined) {
                        highPrice = data[k].limits.previousClosePrice > highPrice ? data[k].limits.previousClosePrice : highPrice;
                        lowPrice = data[k].limits.previousClosePrice < lowPrice ? data[k].limits.previousClosePrice : lowPrice;
                    }
                    var displayRange = (highPrice - lowPrice) / highPrice;
                    canvas.height = Math.max(1, Math.ceil(displayRange * SETTING.DISPLAY_NORMALIZE_RATIO));

                    if (data[k].limits.previousClosePrice != undefined) {
                        context.beginPath();
                        var adjustedPreviousClosePrice = Math.ceil(canvas.height * (highPrice - data[k].limits.previousClosePrice) / (highPrice - lowPrice)) - 0.5;
                        adjustedPreviousClosePrice = adjustedPreviousClosePrice < 0.5 ? 0.5 : adjustedPreviousClosePrice;

                        context.moveTo(0, adjustedPreviousClosePrice);
                        context.lineTo(canvas.width, adjustedPreviousClosePrice);
                        context.setLineDash([3, 2]);
                        context.strokeStyle = '#A9A9A9';
                        context.stroke();
                    }

                    context.beginPath();
                    for (var i = 0; i < data[k].range.length; i++) {
                        var y = canvas.height * (highPrice - data[k].range[i].closePrice) / (highPrice - lowPrice);
                        if (i == 0)
                            context.moveTo(i + 0.5, y);
                        else
                            context.lineTo(i + 0.5, y);
                    }
                    context.setLineDash([0]);
                    context.strokeStyle = 'blue';
                    context.stroke();

                    if (data[k].studies.regression.angle.length > 0) {
                        document.getElementById('angle_' + k).innerHTML = (data[k].studies.regression.angle[data[k].studies.regression.angle.length - 1] * 180 / Math.PI).toStyle(STYLE.DEGREE) + '<br>' + data[k].studies.regression.deviation[data[k].studies.regression.angle.length - 1].toStyle(STYLE.PERMILLE | STYLE.REDUCED | STYLE.GRAY);
                    }

                    if (true) {
                        if (data[k].studies.regression.angle.length > 0) {
                            var p2 = data[k].studies.regression.projection[data[k].studies.regression.angle.length - 1];
                            var p1 = data[k].studies.regression.intersect[data[k].studies.regression.angle.length - 1];

                            var y1 = canvas.height * (highPrice - p1) / (highPrice - lowPrice);
                            var y2 = canvas.height * (highPrice - p2) / (highPrice - lowPrice);

                            context.beginPath();
                            context.moveTo(0.5, y1);
                            context.lineTo(data[k].range.length - 0.5, y2);
                            context.setLineDash([0]);
                            context.strokeStyle = 'red';
                            context.stroke();
                        }
                    }

                    context.beginPath();
                    for (var i = 0; i < data[k].range.length; i++)
                        if (data[k].range[i].traded) {
                            var y = canvas.height * (highPrice - data[k].range[i].closePrice) / (highPrice - lowPrice);
                            var star = document.getElementById('star');
                            context.drawImage(star, i - (star.scrollWidth / 2) + 0.5, y - (star.scrollHeight / 2));
                        }
                }
            }
            catch (e) {
                console.error('UpdateLayout', e);
            }
        };

        var evaluateScrips = false;
        var availableSlots = 10;
        var perSlotBudget = 3000;
        // 26-05-2015 - For Open Range Breakout calculation
        var isOpenRangeCalculated = false;
        EvaluateScrips = function () {
            if (new Date() >= openRangeCalculateTime && !isOpenRangeCalculated) {
                for (var k = 0; k < data.length; k++)
                    data[k].openRangeLimits = {
                        'highPrice': data[k].limits.highPrice,
                        'lowPrice': data[k].limits.lowPrice,
                    };

                isOpenRangeCalculated = true;
            }

            if (isOpenRangeCalculated) {
                var focus = [];
                for (var k = 0; k < data.length; k++)
                    if (!data[k].tradedOpenRange)
                        if (data[k].studies.ema5 > data[k].openRangeLimits.highPrice || data[k].studies.ema5 < data[k].openRangeLimits.lowPrice)
                            focus.push(data[k]);

                focus.sort(function (a, b) {
                });

                for (var j = 0; j < focus.length; j++) {
                    if (availableSlots <= 0)
                        break;
                    // Place order for focus element
                    var LTP = focus[j].LTP[focus[j].LTP.length - 1];
                    var quantity = Math.floor(perSlotBudget / LTP);
                    if (quantity == 0 || LTP < SETTING.MIN_LTP_CONSIDERED)
                        continue;
                    ProcessOrder(focus[j].k, {
                        'TransactionType': 1,
                        'OrderType': 'MARKET',
                        'Quantity': quantity,
                    });
                    availableSlots--;
                }
            }
        };

        CalculateStudies = function (k) {
            var anonFunc1 = (function () {
                data[k].studies.trend = [];
                var step1Count = 1, step2Count = 1;
                var nDMp = 0, nDMn = 0, nTR = 0;
                var nDIu = 0, nDId = 0, nDX = 0;
                for (var n = 1; n < data[k].range.length; n++) {
                    var temp1 = data[k].range[n].highPrice - data[k].range[n - 1].highPrice;
                    var temp2 = data[k].range[n - 1].lowPrice - data[k].range[n].lowPrice;

                    var DMp = temp1 > temp2 ? Math.max(temp1, 0) : 0;
                    var DMn = temp2 > temp1 ? Math.max(temp2, 0) : 0;
                    var TR = data[k].range[n].highPrice - data[k].range[n].lowPrice;

                    if (step1Count < SETTING.ADX_STEP_1_PERIOD) {
                        nDMp += DMp;
                        nDMn += DMn;
                        nTR += TR;
                    }
                    else {
                        if (step1Count == SETTING.ADX_STEP_1_PERIOD) {
                            nDMp = (nDMp + DMp) / SETTING.ADX_STEP_1_PERIOD;
                            nDMn = (nDMn + DMn) / SETTING.ADX_STEP_1_PERIOD;
                            nTR = (nTR + TR) / SETTING.ADX_STEP_1_PERIOD;
                        }
                        else {
                            nDMp = (nDMp * (SETTING.ADX_STEP_1_PERIOD - 1) + DMp) / SETTING.ADX_STEP_1_PERIOD;
                            nDMn = (nDMn * (SETTING.ADX_STEP_1_PERIOD - 1) + DMn) / SETTING.ADX_STEP_1_PERIOD;
                            nTR = (nTR * (SETTING.ADX_STEP_1_PERIOD - 1) + TR) / SETTING.ADX_STEP_1_PERIOD;
                        }

                        var DIu = nDMp / nTR;
                        var DId = nDMn / nTR;
                        var DX = Math.abs(nDMp - nDMn) / (nDMp + nDMn);

                        if (step2Count < SETTING.ADX_STEP_2_PERIOD) {
                            nDIu += DIu;
                            nDId += DId;
                            nDX += DX;
                        }
                        else {
                            if (step2Count == SETTING.ADX_STEP_2_PERIOD) {
                                nDIu = (nDIu + DIu) / SETTING.ADX_STEP_2_PERIOD;
                                nDId = (nDId + DId) / SETTING.ADX_STEP_2_PERIOD;
                                nDX = (nDX + DX) / SETTING.ADX_STEP_2_PERIOD;
                            }
                            else {
                                nDIu = (nDIu * (SETTING.ADX_STEP_2_PERIOD - 1) + DIu) / SETTING.ADX_STEP_2_PERIOD;
                                nDId = (nDId * (SETTING.ADX_STEP_2_PERIOD - 1) + DId) / SETTING.ADX_STEP_2_PERIOD;
                                nDX = (nDX * (SETTING.ADX_STEP_2_PERIOD - 1) + DX) / SETTING.ADX_STEP_2_PERIOD;
                            }

                            data[k].studies.trend.push({
                                'ADX': nDX,
                                '+DI': nDIu,
                                '-DI': nDId,
                            });
                        }
                        step2Count++;
                    }
                    step1Count++;
                }
            })();

            var index = data[k].range.length;
            if (index == 0)
                return;

            if (data[k].studies.regression == undefined)
                data[k].studies.regression = {
                    'slope': [],
                    'intersect': [],
                    'projection': [],
                    'angle': [],
                    'deviation': [],
                    'temp': {
                        'x': 0,
                        'y': 0,
                        'xy': 0,
                        'xx': 0,
                    },
                };

            var x = data[k].studies.regression.temp.x += index;
            var y = data[k].studies.regression.temp.y += data[k].range[index - 1].closePrice;
            var xy = data[k].studies.regression.temp.xy += index * data[k].range[index - 1].closePrice;
            var xx = data[k].studies.regression.temp.xx += index * index;

            if (index != 1) {
                var b = ((index * xy) - (x * y)) / ((index * xx) - (x * x));
                var a = (y - b * x) / index;
                var c = a + b * index;

                data[k].studies.regression.slope.push(b);
                data[k].studies.regression.intersect.push(a);
                data[k].studies.regression.projection.push(c);

                var y1 = SETTING.SLOPE_NORMALIZE_RATIO * (data[k].limits.highPrice - a) / data[k].limits.highPrice;
                var y2 = SETTING.SLOPE_NORMALIZE_RATIO * (data[k].limits.highPrice - c) / data[k].limits.highPrice;
                var d = Math.atan((y1 - y2) / index);
                data[k].studies.regression.angle.push(d);

                var variance = 0;
                for (var i = 0; i < index; i++) {
                    var diff = (data[k].range[i].closePrice - (a + b * i)) / (a + b * i);
                    variance += diff * diff;
                }
                variance /= data[k].range.length;
                var stdDev = Math.sqrt(variance);
                data[k].studies.regression.deviation.push(stdDev);
            }

            if (data[k].studies.stoploss == undefined)
                data[k].studies.stoploss = {
                    'price': [data[k].range[0].lowPrice],
                    'trend': [TREND.BULL],
                    'temp': {
                        'G': data[k].range[0].lowPrice,
                        'L': TREND.BULL,
                        'H': data[k].range[0].highPrice,
                        'I': data[k].range[0].highPrice - data[k].range[0].lowPrice,
                        'J': SETTING.PSAR_INCR_ACC_FACTOR,
                        'K': SETTING.PSAR_INCR_ACC_FACTOR * (data[k].range[0].highPrice - data[k].range[0].lowPrice),
                    },
                };

            if (index != 1) {
                var temp = data[k].studies.stoploss.temp;
                var L = data[k].studies.stoploss.trend[data[k].studies.stoploss.trend.length - 1];

                temp.G = (L == TREND.BULL && ((temp.G + temp.K) > data[k].range[index - 1].lowPrice)) || (L == TREND.BEAR && ((temp.G + temp.K) < data[k].range[index - 1].highPrice)) ? temp.H : temp.G + temp.K;
                temp.L = temp.G < data[k].range[index - 1].highPrice ? TREND.BULL : (temp.G > data[k].range[index - 1].lowPrice ? TREND.BEAR : TREND.NONE);
                switch (temp.L) {
                    case TREND.BULL:
                        if (data[k].range[index - 1].highPrice > temp.H) {
                            temp.H = data[k].range[index - 1].highPrice;
                            if (L == temp.L)
                                temp.J = temp.J + SETTING.PSAR_INCR_ACC_FACTOR;
                        }
                        break;
                    case TREND.BEAR:
                        if (data[k].range[index - 1].lowPrice < temp.H) {
                            temp.H = data[k].range[index - 1].lowPrice;
                            if (L == temp.L)
                                temp.J = temp.J + SETTING.PSAR_INCR_ACC_FACTOR;
                        }
                        break;
                }
                if (L != temp.L)
                    temp.J = SETTING.PSAR_INCR_ACC_FACTOR;
                temp.I = temp.H - temp.G;
                temp.K = temp.J * temp.I;

                data[k].studies.stoploss.price.push(temp.G);
                data[k].studies.stoploss.trend.push(temp.L);
            }


        };

        var deferCalculateRange;
        CalculateRange = function () {
            for (var k = 0; k < data.length; k++) {
                var range = {};
                var LTP = undefined;
                while (LTP = data[k].LTP.shift()) {
                    if (range.openPrice == undefined)
                        range.openPrice = LTP;
                    if (range.highPrice == undefined || LTP > range.highPrice)
                        range.highPrice = LTP;
                    if (range.lowPrice == undefined || LTP < range.lowPrice)
                        range.lowPrice = LTP;
                    range.closePrice = LTP;
                }
                if (range.closePrice != undefined) {
                    range.asOf = new Date();
                    data[k].range.push(range);
                    data[k].LTP.unshift(range.closePrice);
                    // 04-05-2015 - for use in UpdateLayout + specific studies calculation
                    // avoids addtl. loop to determine price range
                    if (data[k].limits.highPrice == undefined || range.highPrice > data[k].limits.highPrice)
                        data[k].limits.highPrice = range.highPrice;
                    if (data[k].limits.lowPrice == undefined || range.lowPrice < data[k].limits.lowPrice)
                        data[k].limits.lowPrice = range.lowPrice;
                    CalculateStudies(k);
                }
            }
            EvaluateScrips();
            UpdateLayout();
        };

        var deferCheckIfOpen;
        var state = STATE.CLOSE;
        CheckIfOpen = function () {
            $.ajax({
                url: 'check-market-open.php?ts=' + new Date().getTime(),
                type: 'POST',
                success: function (result) {
                    if (result.error != undefined) {
                        console.error('CheckIfOpen', result.error);
                        deferCheckIfOpen = setTimeout(CheckIfOpen, SETTING.CHECK_OPEN_RETRY_INTERVAL);
                        return;
                    }

                    if (result.state != 0)
                        deferCheckIfOpen = setTimeout(CheckIfOpen, SETTING.CHECK_OPEN_RETRY_INTERVAL);
                    else {
                        // Market is now open, LTP "changes" from Google can now be considered
                        state = STATE.OPEN;

                        deferGetStartState = setTimeout(GetStartState, SETTING.CHECK_START_STATE_INIT_TIMEOUT);
                        deferCalculateRange = setInterval(CalculateRange, SETTING.STUDIES_CALC_INTERVAL);

                        setTimeout(function () {
                            evaluateScrips = true;
                            setTimeout(function () {
                                evaluateScrips = false;
                            }, evaluateScripsEndTime.getTime() - new Date().getTime());
                        }, evaluateScripsStartTime.getTime() - new Date().getTime());

                        setTimeout(function () {
                            state = STATE.CLOSE;
                            clearInterval(deferCalculateRange);
                        }, marketCloseTime.getTime() - new Date().getTime());
                    }
                },
                error: function (HttpRequest, textStatus, errorThrown) {
                    console.error('CheckIfOpen', HttpRequest, textStatus, errorThrown);
                    deferCheckIfOpen = setTimeout(CheckIfOpen, SETTING.CHECK_OPEN_RETRY_INTERVAL);
                }
            });
        };

        SortScrips = function (sortCondition) {
            var tr = $("#quote_container > tr").get();
            tr.sort(function (a, b) {
                try {
                    var a = parseInt(a.id.split('_')[1]);
                    var b = parseInt(b.id.split('_')[1]);

                    switch (sortCondition) {
                        case SORT.SYMBOL_NAME:
                            return data[a].securitySymbol.localeCompare(data[b].securitySymbol);
                        case SORT.LTP_CHANGE:
                            var a = data[a].limits.previousClosePrice == undefined || data[a].range.length == 0 ? 0 : Math.abs((data[a].range[data[a].range.length - 1].closePrice - data[a].limits.previousClosePrice) / data[a].limits.previousClosePrice);
                            var b = data[b].limits.previousClosePrice == undefined || data[b].range.length == 0 ? 0 : Math.abs((data[b].range[data[b].range.length - 1].closePrice - data[b].limits.previousClosePrice) / data[b].limits.previousClosePrice);
                            return b - a;
                        case SORT.NO_OF_TRADES:
                            var a = data[a].BSEState == undefined ? 0 : data[a].BSEState.noOfTrades;
                            var b = data[b].BSEState == undefined ? 0 : data[b].BSEState.noOfTrades;
                            return b - a;
                        case SORT.C2O_CHANGE:
                            var a = data[a].range.length == 0 ? 0 : Math.abs((data[a].range[data[a].range.length - 1].closePrice - data[a].range[0].openPrice) / data[a].range[0].openPrice);
                            var b = data[b].range.length == 0 ? 0 : Math.abs((data[b].range[data[b].range.length - 1].closePrice - data[b].range[0].openPrice) / data[b].range[0].openPrice);
                            return b - a;
                        case SORT.TREND_STRENGTH:
                            var a = data[a].studies.trend.length > 0 == undefined ? 0 : data[a].studies.trend[data[a].studies.trend.length - 1]['ADX'];
                            var b = data[b].studies.trend.length > 0 == undefined ? 0 : data[b].studies.trend[data[b].studies.trend.length - 1]['ADX'];
                            return b - a;
                        case SORT.SLOPE_ANGLE:
                            var a = data[a].studies.regression == undefined || data[a].studies.regression.angle.length == 0 ? 0 : Math.abs(data[a].studies.regression.angle[data[a].studies.regression.angle.length - 1]);
                            var b = data[b].studies.regression == undefined || data[b].studies.regression.angle.length == 0 ? 0 : Math.abs(data[b].studies.regression.angle[data[b].studies.regression.angle.length - 1]);
                            return b - a;
                    }
                }
                catch (e) {
                    return 0;
                }
            });
            for (var i = 0; i < tr.length; i++)
                tr[i].parentNode.appendChild(tr[i]);
        };

        var google;
        BeginGoogle = function () {
            // URL is subject to browser & OS
            google = window.open('https://www.google.com/intl/en/about/#SAFE', 'WND-GOOGLE-HOME');
        };

        var religare;
        BeginReligare = function () {
            window.open('https://secure.religareonline.com/Login.aspx?rdrURL=https%3A//secure.religareonline.com/OrderBook.aspx%3Fassettype%3DEquity', 'WND-RELIGARE-ORDER');
        };

        DoSomething = function () {
            try {
                $.getJSON('data.json', function (data) {
                    window.data = data;
                    for (var k = 0; k < data.length; k++) {
                        data[k].k = k;
                        data[k].LTP = [];
                        data[k].range = [];
                        data[k].studies = {};
                        data[k].limits = {};
                        // add k to dataPendingStartState; processing will start only later (once CheckIfOpen passes)
                        dataPendingStartState.push(k);
                    }
                    // Set-up the initial table layout
                    UpdateLayout();
                    // In case, execution time post marketSpeculativeOpenTime, immediately executed (setTimeout doesn't recognize -ve times)
                    deferCheckIfOpen = setTimeout(CheckIfOpen, marketSpeculativeOpenTime.getTime() - new Date().getTime());
                });
            }
            catch (e) {
                // In the unlikely event that jquery is not loaded before this function is executed
                setTimeout(DoSomething, SETTING.DO_SOMETHING_RETRY_INTERVAL);
            }
        };

        window.addEventListener('message', ProcessMessage, false);

        window.onbeforeunload = function () {
            return 'You might have open positions.';
        };

        DoSomething();
    </script>

    <span style="font-family:Verdana;">
        <img id="star" src="star.png" /> indicates executed trade
    </span>

    <div style="position:absolute;display:block;font-size:10px;font-family:Verdana;right:0px;">
        <table style="padding-right:8px;">
            <tr>
                <td class="no-border" style="text-align:right">
                    <a href="javascript:BeginGoogle()">
                        Google:&nbsp;
                    </a>
                </td>
                <td id="state_google" class="no-border" style="color:#D14836;">
                    OFF
                </td>
            </tr>
            <tr>
                <td class="no-border" style="text-align:right">
                    <a href="javascript:BeginReligare()">
                        Religare:&nbsp;
                    </a>
                </td>
                <td id="state_religare" class="no-border" style="color:#D14836;">
                    OFF
                </td>
            </tr>
        </table>
    </div>

    <div style="float:left;padding-right:8px">
        <table style="font-size:10px;font-family:Verdana;border-color:black;border-top:1px solid #C8EFEA;border-left:1px solid #C8EFEA;margin:0px;padding:0px" border="0" cellspacing="0" cellpadding="2">
            <thead>
                <tr>
                    <th id="scrip_top" class="sort" style="width:90px;" rowspan="2">Scrip</th>
                    <th id="ltp_top" class="sort" style="width:55px;">LTP<br />%Chg</th>
                    <th style="width:200px;">Chart</th>
                    <th id="trades_top" class="sort" style="width:55px;">No. of<br />trades</th>
                    <th id="ohlc_top" class="sort" style="width:55px;">C to O<br />H to L</th>
                    <th style="width:200px;">Trend</th>
                    <th id="adx_top" class="sort" style="width:85px;">ADX<br />+DI / -DI</th>
                    <th style="width:200px;">Slope</th>
                    <th id="angle_top" class="sort" style="width:55px;">&theta;<br />&sigma;</th>
                </tr>
            </thead>
            <tbody id="quote_container" style="text-align:right">
                <tr id="quote_no_rows">
                    <td colspan="9" style="text-align:center">
                        -
                    </td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
        $('th#scrip_top').click(function () {
            SortScrips(SORT.SYMBOL_NAME);
        });
        $('th#ltp_top').click(function () {
            SortScrips(SORT.LTP_CHANGE);
        });
        $('th#trades_top').click(function () {
            SortScrips(SORT.NO_OF_TRADES);
        });
        $('th#ohlc_top').click(function () {
            SortScrips(SORT.C2O_CHANGE);
        });
        $('th#adx_top').click(function () {
            SortScrips(SORT.TREND_STRENGTH);
        });
        $('th#angle_top').click(function () {
            SortScrips(SORT.SLOPE_ANGLE);
        });
    </script>
</body>

</html>
