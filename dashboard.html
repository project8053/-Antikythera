<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Dashboard</title>
    <script src="./jquery-2.1.1.min.js"></script>
    <!-- 03-01-2016 - Removed rarely changed elements to common.js -->
    <script src="./common.js"></script>
    <style>
        th {
            border-right: 1px solid #C8EFEA;
            border-bottom: 1px solid #C8EFEA;
            color: #FFFFFF;
            background-color: #25B3A2;
        }

        th.sort {
            cursor: ns-resize;
        }

        td {
            border-right: 1px solid #C8EFEA;
            border-bottom: 1px solid #C8EFEA;
            color: #1C355D;
            background-color: #F8F8E4;
        }

        td.no-border {
            border-right: 0px none #000000;
            border-bottom: 0px none #000000;
            background-color: rgba(0, 0, 0, 0);
        }

        div {
            margin-bottom: 10px;
        }

        a:link {
            text-decoration: none;
            color: #1C355D;
        }

        a:visited {
            text-decoration: none;
            color: #1C355D;
        }

        a:hover {
            text-decoration: none;
            color: #25B3A2;
        }

        a:active {
            text-decoration: none;
            color: #25B3A2;
        }
    </style>
</head>
<body style="width: 2100px; font-family: Verdana; font-size: 10px">
    <!-- 03-01-2016 - Removed rarely changed elements to common.js -->
    <script>
        /*  Add source-specific SETTING variables here
        E.g. SETTING.SAMPLE_VAR = 1;

        See common.js for pre-defined variables
        */

        var marketSpeculativeOpenTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 9, 14);
        var marketCloseTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 15, 30);
        var startStatePollEndTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 9, 55);
        var evaluateScripsStartTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 11, 0);
        var evaluateScripsEndTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 14, 0);
        // 26-05-2015 - For Open Range Breakout calculation
        var openRangeCalculateTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 10, 30);
        // 10-08-2015 - For squaring off open orders
        var squareOffTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 15, 0);

        var rangeStableTime = new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 9, 30);




        var connected = false;
        // connected to religare window
        ProcessMessage = function (event) {
            switch (event.data.type) {
                case CONTENT_TYPE.GOOGL_INITIALIZE:
                    var symbol = [];
                    for (var k = 0; k < data.length; k++)
                        symbol.push(data[k].symbol);
                    google.postMessage({
                        'type': CONTENT_TYPE.GOOGL_SETUP_DATA,
                        'symbol': symbol
                    }, '*');
                    var td = document.getElementById('state_google');
                    td.style.color = '#093';
                    td.innerHTML = 'ON';
                    break;

                case CONTENT_TYPE.GOOGL_POST_LTP:
                    if (state == STATE.OPEN)
                    // No possibility of previous close being mistaken for today's LTP as Google never posts the first LTP it encounters
                        UpdateLTP(event.data.k, event.data.LTP);
                    break;

                case CONTENT_TYPE.RELGR_INITIALIZE:
                    religare = event.source;
                    connected = true;
                    var td = document.getElementById('state_religare');
                    td.style.color = '#093';
                    td.innerHTML = 'ON';
                    // 08-08-2015 - Update global fund data; if not availble, display message
                    if (event.data.funds != 0)
                        UpdateAvailableFunds(event.data.funds);
                    else
                        alert('Funds information not available.\nExecute ‘UpdateAvailableFunds(₹...)’ manually.');
                    break;

                case CONTENT_TYPE.RELGR_ORDER_STATUS_UPDATE:
                    // details includes total executed summary at point of time + details of last executed order(s) 
                    TrackOrdersStatus(event.data.k, event.data.details);
                    break;
            }
        };

        ProcessOrder = function (k, details) {
            if (!connected)
                console.error('Religare is offline');
            else {
                details['SecurityID'] = data[k].symbol;
                details['TradingSymbol'] = data[k].securitySymbol;
                details['Series'] = data[k].securitySeries;

                religare.postMessage({
                    'type': CONTENT_TYPE.RELGR_PROCESS_ORDER,
                    'details': details
                }, '*');
            }
        };

        UpdateLTP = function (k, LTP) {
            data[k].LTP.push(LTP);
            if (document.getElementById('ltp_' + k) != null) {
                var msg = LTP + '<br>';
                if (data[k].limits.previousClosePrice != undefined)
                    msg += ((LTP - data[k].limits.previousClosePrice) / data[k].limits.previousClosePrice).toStyle(STYLE.PERCENT);
                else
                    msg += '-';
                document.getElementById('ltp_' + k).innerHTML = msg;
            }
        };

        DisplayMetrics = function (k, i) {
            if (i < 0 || i >= data[k].range.length)
                return;

            var offset = {};
            if (data[k].studies.regression != undefined) {
                if (data[k].studies.regression.all.angle.length > 0)
                    if (i >= data[k].range.length - data[k].studies.regression.all.angle.length)
                        offset['regression.all'] = i - data[k].range.length + data[k].studies.regression.all.angle.length;
                if (data[k].studies.regression.n.angle.length > 0)
                    if (i >= data[k].range.length - data[k].studies.regression.n.angle.length)
                        offset['regression.n'] = i - data[k].range.length + data[k].studies.regression.n.angle.length;
            }

            var offsetAngleAll = data[k].studies.regression == undefined ? undefined : data[k].range.length - data[k].studies.regression.all.angle.length;
            var offsetAngleN = data[k].studies.regression == undefined ? undefined : data[k].range.length - data[k].studies.regression.all.angle.length;

            var el = document.getElementById('metrics');
            el.style.visibility = 'visible';
            el.children[0].innerHTML = '#' + k + ' (i: ' + i + ')' 
                                    + '<br>CP: ' + data[k].range[i].closePrice
                                    + '<br>θ (all): ' + (offset['regression.all'] != undefined ? data[k].studies.regression.all.angle[offset['regression.all']].toStyle(STYLE.DEGREE) : '-')
                                    + '<br>θ (n): ' + (offset['regression.n'] != undefined ? data[k].studies.regression.n.angle[offset['regression.n']].toStyle(STYLE.DEGREE) : '-');

            var el2 = document.getElementById('pointer');
            el2.style.visibility = 'visible';
            el2.style.top = ($('#visualisation_' + k).offset().top - 4) + 'px';
            el2.style.height = ($('#visualisation_' + k).innerHeight() + 4 * 2) + 'px';
            el2.style.left = ($('#visualisation_' + k).offset().left + i + 2) + 'px';             
        };

        HideMetrics = function () {
            document.getElementById('metrics').style.visibility = 'hidden';
            document.getElementById('pointer').style.visibility = 'hidden';
        };

        UpdateLayout = function () {
            try {
                for (var k = 0; k < data.length; k++) {
                    if (document.getElementById('quote_' + k) == null) {
                        var noRows = document.getElementById('quote_no_rows');
                        if (noRows != null)
                            noRows.parentNode.removeChild(noRows);
                        var row = document.createElement('tr');
                        row.id = 'quote_' + k;
                        row.innerHTML = '<td style="text-align:left;"><a href="https://www.google.com/finance?q=BOM%3A' + data[k].symbol + '" target="_blank">' + data[k].securitySymbol + '</a><br>#' + k + '</td><td id="ltp_' + k + '">-<br>-</td><td id="visualisation_' + k + '"><canvas id="chart_' + k + '" height="30" width="200"></canvas><br><canvas id="slope_' + k + '" height="30" width="200"></canvas></td><td id="trades_' + k + '">-</td><td id="ohlc_' + k + '"></td><td><canvas id="trend_' + k + '" height="30" width="200"></canvas></td><td id="adx_' + k + '"></td><td></td><td id="angle_' + k + '">-</td>';
                        document.getElementById('quote_container').appendChild(row);

                        // Support for visualisation to easily identify studies & range
                        document.getElementById('visualisation_' + k).addEventListener('mousemove', function (e) {
                            var _k = this.id.split('_')[1];
                            var x = e.clientX - document.getElementById('chart_' + _k).getBoundingClientRect().left;
                            DisplayMetrics(_k, x);
                        });
                    }

                    if (data[k].range.length == 0)
                        continue;

                    var highPrice = data[k].limits.highPrice;
                    var lowPrice = data[k].limits.lowPrice;
                    document.getElementById('ohlc_' + k).innerHTML = ((data[k].range[data[k].range.length - 1].closePrice - data[k].range[0].openPrice) / data[k].range[0].openPrice).toStyle(STYLE.PERCENT) + '<br>' + ((highPrice - lowPrice) / lowPrice).toStyle(STYLE.PERCENT | STYLE.GRAY | STYLE.REDUCED);

                    var canvas = document.getElementById('chart_' + k);
                    var context = canvas.getContext('2d');

                    if (data[k].limits.previousClosePrice != undefined) {
                        highPrice = data[k].limits.previousClosePrice > highPrice ? data[k].limits.previousClosePrice : highPrice;
                        lowPrice = data[k].limits.previousClosePrice < lowPrice ? data[k].limits.previousClosePrice : lowPrice;
                    }
                    var displayRange = (highPrice - lowPrice) / highPrice;
                    canvas.height = Math.max(1, Math.ceil(displayRange * SETTING.DISPLAY_NORMALIZE_RATIO));

                    if (data[k].limits.previousClosePrice != undefined) {
                        context.beginPath();
                        var adjustedPreviousClosePrice = Math.ceil(canvas.height * (highPrice - data[k].limits.previousClosePrice) / (highPrice - lowPrice)) - 0.5;
                        adjustedPreviousClosePrice = adjustedPreviousClosePrice < 0.5 ? 0.5 : adjustedPreviousClosePrice;

                        context.moveTo(0, adjustedPreviousClosePrice);
                        context.lineTo(canvas.width, adjustedPreviousClosePrice);
                        context.setLineDash([3, 2]);
                        context.strokeStyle = '#A9A9A9';
                        context.stroke();
                    }

                    context.beginPath();
                    for (var i = 0; i < data[k].range.length; i++) {
                        var y = canvas.height * (highPrice - data[k].range[i].closePrice) / (highPrice - lowPrice);
                        if (i == 0)
                            context.moveTo(i + 0.5, y);
                        else
                            context.lineTo(i + 0.5, y);
                    }
                    context.setLineDash([0]);
                    context.strokeStyle = 'blue';
                    context.stroke();

                    context.beginPath();
                    for (var i = 0; i < data[k].studies.ma.ema5.length; i++) {
                        var y = canvas.height * (highPrice - data[k].studies.ma.ema5[i]) / (highPrice - lowPrice);
                        if (i == 0)
                            context.moveTo(i + 0.5, y);
                        else
                            context.lineTo(i + 0.5, y);
                    }
                    context.setLineDash([0]);
                    context.strokeStyle = 'red';
                    context.stroke();

                    if (data[k].studies.regression != undefined) {
                        document.getElementById('angle_' + k).innerHTML = data[k].studies.regression.all.angle[data[k].studies.regression.all.angle.length - 1].toStyle(STYLE.DEGREE) + '<br>';
                        if (data[k].studies.regression.n.angle.length > 0)
                            document.getElementById('angle_' + k).innerHTML += data[k].studies.regression.n.angle[data[k].studies.regression.n.angle.length - 1].toStyle(STYLE.DEGREE | STYLE.REDUCED)
                        else
                            document.getElementById('angle_' + k).innerHTML += '-';
                    }

                    if (data[k].studies.regression != undefined) {
                        if (data[k].studies.regression.n.slope.length > 0) {
                            var m = data[k].studies.regression.n.slope[data[k].studies.regression.n.slope.length - 1];
                            var b = data[k].studies.regression.n.intercept[data[k].studies.regression.n.slope.length - 1];

                            var p1 = m * (data[k].range.length - SETTING.SLOPE_MIN_COUNT - 10) + b;
                            var p2 = m * (data[k].range.length + 10) + b;

                            var y1 = canvas.height * (highPrice - p1) / (highPrice - lowPrice);
                            var y2 = canvas.height * (highPrice - p2) / (highPrice - lowPrice);

                            context.beginPath();
                            context.moveTo(data[k].range.length - SETTING.SLOPE_MIN_COUNT - 10 - 0.5, y1);
                            context.lineTo(data[k].range.length + 10 - 0.5, y2);
                            context.setLineDash([0]);
                            context.strokeStyle = 'green';
                            context.stroke();

                            var canvas2 = document.getElementById('slope_' + k);
                            var angleMin = 0, angleMax = 0;
                            for (var i = 0; i < data[k].studies.regression.all.angle.length; i++) {
                                angleMin = data[k].studies.regression.all.angle[i] < angleMin ? data[k].studies.regression.all.angle[i] : angleMin;
                                angleMax = data[k].studies.regression.all.angle[i] > angleMax ? data[k].studies.regression.all.angle[i] : angleMax;
                            }
                            for (var i = 0; i < data[k].studies.regression.n.angle.length; i++) {
                                angleMin = data[k].studies.regression.n.angle[i] < angleMin ? data[k].studies.regression.n.angle[i] : angleMin;
                                angleMax = data[k].studies.regression.n.angle[i] > angleMax ? data[k].studies.regression.n.angle[i] : angleMax;
                            }
                            // 90 pixels = 180° change
                            SETTING.ANGLE_NORMALIZE_RATIO = 90 / 180;
                            canvas2.height = Math.max(1, Math.ceil((angleMax - angleMin) * SETTING.ANGLE_NORMALIZE_RATIO));

                            var context2 = canvas2.getContext('2d');

                            var zeroPoint = Math.ceil(canvas2.height * angleMax / (angleMax - angleMin)) - 0.5;
                            zeroPoint = zeroPoint < 0.5 ? 0.5 : zeroPoint;
                            context2.moveTo(0, zeroPoint);
                            context2.lineTo(canvas.width, zeroPoint);
                            context2.setLineDash([3, 2]);
                            context2.strokeStyle = '#A9A9A9';
                            context2.stroke();

                            context2.beginPath();
                            for (var i = 0; i < data[k].studies.regression.n.angle.length; i++) {
                                var y = canvas2.height * (angleMax - data[k].studies.regression.n.angle[i]) / (angleMax - angleMin);
                                if (i == 0)
                                    context2.moveTo(i + SETTING.SLOPE_MIN_COUNT + 0.5, y);
                                else
                                    context2.lineTo(i + SETTING.SLOPE_MIN_COUNT + 0.5, y);
                            }
                            context2.setLineDash([1, 1]);
                            context2.strokeStyle = 'blue';
                            context2.stroke();

                            context2.beginPath();
                            var offset = data[k].range.length - data[k].studies.regression.all.angle.length;
                            for (var i = 0; i < data[k].studies.regression.all.angle.length; i++) {
                                var y = canvas2.height * (angleMax - data[k].studies.regression.all.angle[i]) / (angleMax - angleMin);
                                if (i == 0)
                                    context2.moveTo(i + offset + 0.5, y);
                                else
                                    context2.lineTo(i + offset + 0.5, y);
                            }
                            context2.setLineDash([0]);
                            context2.strokeStyle = 'blue';
                            context2.stroke();

                            /*
                            context2.beginPath();
                            for (var i = 0; i < data[k].studies.regression.n.angle.length; i++) {
                            var y = canvas2.height * (angleMax - data[k].studies.regression.n.angle[i]) / (angleMax - angleMin);
                            if (i == 0)
                            context2.moveTo(i + SETTING.SLOPE_MIN_COUNT + 0.5, y);
                            else
                            context2.lineTo(i + SETTING.SLOPE_MIN_COUNT + 0.5, y);
                            }
                            context2.setLineDash([0]);
                            context2.strokeStyle = 'green';
                            context2.stroke(); */
                        }
                    }

                    // Show executed buy & sell operations
                    context.beginPath();
                    if (data[k].trades != undefined && data[k].trades.all.length > 0)
                        for (var i = 0; i < data[k].trades.all.length; i++) {
                            var x = data[k].trades.all[i].atPos;
                            var y = canvas.height * (highPrice - data[k].trades.all[i].executedPrice) / (highPrice - lowPrice);
                            var img = document.getElementById(data[k].trades.all[i].transactionType == TRANSACTION_TYPE.BUY ? 'buy' : 'sell');
                            context.drawImage(img, x - (img.scrollWidth / 2) + 0.5, y - (img.scrollHeight / 2));
                        }
                    /*
                    // Show PSAR
                    context.beginPath();
                    context.setLineDash([3, 2]);
                    context.strokeStyle = 'black';
                    var trend = data[k].studies.stoploss.trend[0];
                    for (var i = 0; i < data[k].studies.stoploss.price.length; i++) {
                    var y = canvas.height * (highPrice - data[k].studies.stoploss.price[i]) / (highPrice - lowPrice);
                    if (trend != data[k].studies.stoploss.trend[i]) {
                    context.stroke();
                    context.beginPath();
                    context.moveTo(i + 0.5, y);
                    trend = data[k].studies.stoploss.trend[i];
                    }
                    else if (i == 0)
                    context.moveTo(i + 0.5, y);
                    else
                    context.lineTo(i + 0.5, y);
                    }
                    context.stroke();
                    */
                }
            }
            catch (e) {
                console.error('UpdateLayout', e);
            }
        };

        // 10-08-2015 - For squaring off open orders
        var squareOff = false;
        SquareOff = function () {
            if (!connected)
                console.error('Religare is offline');
            else
                religare.postMessage({ 'type': CONTENT_TYPE.RELGR_SQUARE_OFF }, '*');
            squareOff = true;
        };

        TrackOrdersStatus = function (k, details) {
            console.log(k, details);
            if (details.lastExecuted != undefined && details.lastExecuted.length != 0) {
                if (data[k].trades == undefined)
                    data[k].trades = {
                        'BUYQty': 0,
                        'SELLQty': 0,
                        'all': []
                    };

                data[k].trades.BUYQty = details.summary.BUYQty;
                data[k].trades.SELLQty = details.summary.SELLQty;

                for (var i = 0; i < details.lastExecuted.length; i++) {
                    if (data[k].trades.BUYQty != data[k].trades.SELLQty)
                    // lastExecuted is available only if there is a mis-balance of BUY & SELL
                        data[k].trades.lastExecuted = {
                            'transactionType': details.lastExecuted[i].transactionType,
                            'executedPrice': details.lastExecuted[i].executedPrice,
                            'quantity': details.lastExecuted[i].quantity
                        };
                    else
                        delete data[k].trades.lastExecuted;

                    // For use in displaying trades in canvas + error checking
                    data[k].trades.all.push({
                        'transactionType': details.lastExecuted[i].transactionType,
                        'executedPrice': details.lastExecuted[i].executedPrice,
                        'atPos': data[k].range.length
                    });
                }
            }
            console.log(JSON.stringify(data[k].trades));
        };

        var evaluateScrips = false;
        // 26-05-2015 - For Open Range Breakout calculation
        var isOpenRangeCalculated = false;
        var focus = [];
        EvaluateScrips = function () {
            if (new Date() >= squareOffTime) {
                if (!squareOff)
                    SquareOff();
                return;
            }

            // TEMPORARY FIX to prevent evaluation of open range
            isOpenRangeCalculated = true;

            if (new Date() >= openRangeCalculateTime && !isOpenRangeCalculated) {
                for (var k = 0; k < data.length; k++)
                    data[k].openRangeLimits = {
                        'highPrice': data[k].limits.highPrice,
                        'lowPrice': data[k].limits.lowPrice
                    };

                isOpenRangeCalculated = true;

                focus = data.filter(function (o) {
                    return o.openRangeLimits.highPrice < SETTING.MAX_LTP_CONSIDERED && o.openRangeLimits.lowPrice > SETTING.MIN_LTP_CONSIDERED;
                });
                focus.sort(function (a, b) {
                    var a = Math.max((a.openRangeLimits.highPrice - a.limits.openPrice) / a.limits.openPrice, (a.limits.openPrice - a.openRangeLimits.lowPrice) / a.limits.openPrice);
                    var b = Math.max((b.openRangeLimits.highPrice - b.limits.openPrice) / b.limits.openPrice, (b.limits.openPrice - b.openRangeLimits.lowPrice) / b.limits.openPrice);
                    return b - a;
                });
                focus.splice(SETTING.MAX_FOCUS_CONSIDERED, focus.length - SETTING.MAX_FOCUS_CONSIDERED);
            }

            if (focus.length != 0) {
                for (var j = 0; j < focus.length; j++) {
                    if (!focus[j].tradedOpenRange && availableSlots > 0) {
                        var ema5 = focus[j].studies.ma.ema5[focus[j].studies.ma.ema5.length - 1];
                        if (ema5 > focus[j].openRangeLimits.highPrice || ema5 < focus[j].openRangeLimits.lowPrice) {
                            // BUY (1) when ema5 rises above previous high; else SELL (2)
                            var transactionType = ema5 > focus[j].openRangeLimits.highPrice ? TRANSACTION_TYPE.BUY : TRANSACTION_TYPE.SELL;
                            var quantity = Math.floor(perSlotBudget / focus[j].LTP[focus[j].LTP.length - 1]);

                            ProcessOrder(focus[j].k, {
                                'TransactionType': transactionType,
                                'OrderType': 'MARKET',
                                'Quantity': quantity
                            });

                            //var triggerPrice = ema5 > focus[j].openRangeLimits.highPrice ? focus[j].openRangeLimits.lowPrice : focus[j].openRangeLimits.highPrice;
                            var triggerPrice = ema5 > focus[j].openRangeLimits.highPrice ? Math.floor(focus[j].openRangeLimits.highPrice * (1 - 0.0025) * 20) / 20 : Math.ceil(focus[j].openRangeLimits.lowPrice * (1 + 0.0025) * 20) / 20;
                            ProcessOrder(focus[j].k, {
                                'TransactionType': transactionType == TRANSACTION_TYPE.BUY ? TRANSACTION_TYPE.SELL : TRANSACTION_TYPE.BUY,
                                'OrderType': 'SL MARKET',
                                'TriggerPrice': triggerPrice,
                                'Quantity': quantity
                            });
                            availableSlots--;

                            focus[j].tradedOpenRange = true;
                        }
                    }
                }
            }

            var k = 0;
            while (availableSlots > 0) {
                if (data[k].trades != undefined)
                    if (data[k].trades.lastExecuted != undefined) {
                        var ema = data[k].studies.ma.ema5[data[k].studies.ma.ema5.length - 1];
                        var quantity = data[k].trades.lastExecuted.quantity;
                        var stoplossQuantity = Math.abs(data[k].trades.BUYQty - data[k].trades.SELLQty) + quantity;

                        switch (data[k].trades.lastExecuted.transactionType) {
                            case TRANSACTION_TYPE.BUY:
                                if (ema > data[k].trades.lastExecuted.executedPrice * (1 + 0.0033)) {
                                    ProcessOrder(k, {
                                        'TransactionType': TRANSACTION_TYPE.BUY,
                                        'OrderType': 'MARKET',
                                        'Quantity': quantity
                                    });

                                    var triggerPrice = data[k].trades.lastExecuted.executedPrice * (1 - 0.0067);
                                    ProcessOrder(k, {
                                        'TransactionType': TRANSACTION_TYPE.SELL,
                                        'OrderType': 'SL MARKET',
                                        'TriggerPrice': triggerPrice,
                                        'Quantity': stoplossQuantity
                                    });

                                    console.log(k, 'BUY', quantity, data[k].trades.lastExecuted.executedPrice, ema, triggerPrice, stoplossQuantity);
                                    availableSlots--;
                                    delete data[k].trades.lastExecuted;
                                }
                                break;
                            case TRANSACTION_TYPE.SELL:
                                if (ema < data[k].trades.lastExecuted.executedPrice * (1 - 0.0033)) {
                                    ProcessOrder(k, {
                                        'TransactionType': TRANSACTION_TYPE.SELL,
                                        'OrderType': 'MARKET',
                                        'Quantity': quantity
                                    });

                                    var triggerPrice = data[k].trades.lastExecuted.executedPrice * (1 + 0.0067);
                                    ProcessOrder(k, {
                                        'TransactionType': TRANSACTION_TYPE.BUY,
                                        'OrderType': 'SL MARKET',
                                        'TriggerPrice': triggerPrice,
                                        'Quantity': stoplossQuantity
                                    });

                                    console.log(k, 'SELL', quantity, data[k].trades.lastExecuted.executedPrice, ema, triggerPrice, stoplossQuantity);
                                    availableSlots--;
                                    data[k].trades.lastExecuted;
                                }
                                break;
                        }
                    }
                k++;
                if (k >= data.length)
                    break;
            }
        };

        CalculateStudies = function (k) {

            if (data[k].studies.ma == undefined)
                data[k].studies.ma = {
                    'ema5': [],
                    'ema5High': [],
                    'ema5Low': [],
                    'temp': {
                        'total5': 0,
                        'total5High': 0,
                        'total5Low': 0
                    }
                };

            if (data[k].range.length <= 5) {
                data[k].studies.ma.temp.total5 += data[k].range[data[k].range.length - 1].closePrice;
                data[k].studies.ma.ema5.push(data[k].studies.ma.temp.total5 / data[k].range.length);

                data[k].studies.ma.temp.total5High += data[k].range[data[k].range.length - 1].highPrice;
                data[k].studies.ma.ema5High.push(data[k].studies.ma.temp.total5High / data[k].range.length);

                data[k].studies.ma.temp.total5Low += data[k].range[data[k].range.length - 1].lowPrice;
                data[k].studies.ma.ema5Low.push(data[k].studies.ma.temp.total5Low / data[k].range.length);
            }
            else {
                data[k].studies.ma.ema5.push((data[k].studies.ma.ema5[data[k].studies.ma.ema5.length - 1] * 4 + data[k].range[data[k].range.length - 1].closePrice) / 5);
                data[k].studies.ma.ema5High.push((data[k].studies.ma.ema5High[data[k].studies.ma.ema5High.length - 1] * 4 + data[k].range[data[k].range.length - 1].highPrice) / 5);
                data[k].studies.ma.ema5Low.push((data[k].studies.ma.ema5Low[data[k].studies.ma.ema5Low.length - 1] * 4 + data[k].range[data[k].range.length - 1].lowPrice) / 5);
            }

            if (new Date() >= rangeStableTime && data[k].studies.focus == undefined) {
                data[k].studies.focus = {
                    'price': 1
                };
            }

            var anonFunc1 = (function () {
                data[k].studies.trend = [];
                var step1Count = 1, step2Count = 1;
                var nDMp = 0, nDMn = 0, nTR = 0;
                var nDIu = 0, nDId = 0, nDX = 0;
                for (var n = 1; n < data[k].range.length; n++) {
                    var temp1 = data[k].range[n].highPrice - data[k].range[n - 1].highPrice;
                    var temp2 = data[k].range[n - 1].lowPrice - data[k].range[n].lowPrice;

                    var DMp = temp1 > temp2 ? Math.max(temp1, 0) : 0;
                    var DMn = temp2 > temp1 ? Math.max(temp2, 0) : 0;
                    var TR = data[k].range[n].highPrice - data[k].range[n].lowPrice;

                    if (step1Count < SETTING.ADX_STEP_1_PERIOD) {
                        nDMp += DMp;
                        nDMn += DMn;
                        nTR += TR;
                    }
                    else {
                        if (step1Count == SETTING.ADX_STEP_1_PERIOD) {
                            nDMp = (nDMp + DMp) / SETTING.ADX_STEP_1_PERIOD;
                            nDMn = (nDMn + DMn) / SETTING.ADX_STEP_1_PERIOD;
                            nTR = (nTR + TR) / SETTING.ADX_STEP_1_PERIOD;
                        }
                        else {
                            nDMp = (nDMp * (SETTING.ADX_STEP_1_PERIOD - 1) + DMp) / SETTING.ADX_STEP_1_PERIOD;
                            nDMn = (nDMn * (SETTING.ADX_STEP_1_PERIOD - 1) + DMn) / SETTING.ADX_STEP_1_PERIOD;
                            nTR = (nTR * (SETTING.ADX_STEP_1_PERIOD - 1) + TR) / SETTING.ADX_STEP_1_PERIOD;
                        }

                        var DIu = nDMp / nTR;
                        var DId = nDMn / nTR;
                        var DX = Math.abs(nDMp - nDMn) / (nDMp + nDMn);

                        if (step2Count < SETTING.ADX_STEP_2_PERIOD) {
                            nDIu += DIu;
                            nDId += DId;
                            nDX += DX;
                        }
                        else {
                            if (step2Count == SETTING.ADX_STEP_2_PERIOD) {
                                nDIu = (nDIu + DIu) / SETTING.ADX_STEP_2_PERIOD;
                                nDId = (nDId + DId) / SETTING.ADX_STEP_2_PERIOD;
                                nDX = (nDX + DX) / SETTING.ADX_STEP_2_PERIOD;
                            }
                            else {
                                nDIu = (nDIu * (SETTING.ADX_STEP_2_PERIOD - 1) + DIu) / SETTING.ADX_STEP_2_PERIOD;
                                nDId = (nDId * (SETTING.ADX_STEP_2_PERIOD - 1) + DId) / SETTING.ADX_STEP_2_PERIOD;
                                nDX = (nDX * (SETTING.ADX_STEP_2_PERIOD - 1) + DX) / SETTING.ADX_STEP_2_PERIOD;
                            }

                            data[k].studies.trend.push({
                                'ADX': nDX,
                                '+DI': nDIu,
                                '-DI': nDId
                            });
                        }
                        step2Count++;
                    }
                    step1Count++;
                }
            })();

            SETTING.SLOPE_MIN_COUNT = 30;
            //SETTING.SLOPE_DEV_MIN_COUNT = 15;

            if (data[k].studies.regression == undefined)
                data[k].studies.regression = {
                    'all': {
                        'slope': [],
                        'intercept': [],
                        'angle': [],
                        'deviation': []
                    },
                    'n': {
                        'slope': [],
                        'intercept': [],
                        'angle': [],
                        'deviation': []
                    },
                    'turns': []
                };

            var index = data[k].range.length;

            if (index >= 1) {
                var x = 0, xx = 0, y = 0, xy = 0;
                for (var i = 0; i < index; i++) {
                    x += (i + 1);
                    xx += (i + 1) * (i + 1);
                    y += data[k].range[i].closePrice;
                    xy += (i + 1) * data[k].range[i].closePrice;
                }

                var m = ((index * xy) - (x * y)) / ((index * xx) - (x * x));
                data[k].studies.regression.all.slope.push(m);

                var b = (y - m * x) / index;
                data[k].studies.regression.all.intercept.push(b);

                var p1 = b; // x = 0, y = mx + b
                var p2 = m * index + b; // x = index

                // Changed highPrice to previousClosePrice
                var y1 = SETTING.DISPLAY_NORMALIZE_RATIO * (data[k].limits.previousClosePrice - p1) / data[k].limits.previousClosePrice;
                var y2 = SETTING.DISPLAY_NORMALIZE_RATIO * (data[k].limits.previousClosePrice - p2) / data[k].limits.previousClosePrice;

                var angle = Math.atan((y1 - y2) / SETTING.SLOPE_MIN_COUNT) * 180 / Math.PI;
                data[k].studies.regression.all.angle.push(angle);
            }

            if (data[k].range.length >= SETTING.SLOPE_MIN_COUNT) {
                var x = 0, xx = 0, y = 0, xy = 0;
                for (var i = data[k].range.length - SETTING.SLOPE_MIN_COUNT; i < data[k].range.length; i++) {
                    x += (i + 1);
                    xx += (i + 1) * (i + 1);
                    y += data[k].range[i].closePrice;
                    xy += (i + 1) * data[k].range[i].closePrice;
                }

                var m = ((SETTING.SLOPE_MIN_COUNT * xy) - (x * y)) / ((SETTING.SLOPE_MIN_COUNT * xx) - (x * x));
                data[k].studies.regression.n.slope.push(m);

                var b = (y - m * x) / SETTING.SLOPE_MIN_COUNT;
                data[k].studies.regression.n.intercept.push(b);

                var p1 = b; // x = 0, y = mx + b
                var p2 = m * SETTING.SLOPE_MIN_COUNT + b; // x = SETTING.SLOPE_MIN_COUNT

                // Changed highPrice to previousClosePrice
                var y1 = SETTING.DISPLAY_NORMALIZE_RATIO * (data[k].limits.previousClosePrice - p1) / data[k].limits.previousClosePrice;
                var y2 = SETTING.DISPLAY_NORMALIZE_RATIO * (data[k].limits.previousClosePrice - p2) / data[k].limits.previousClosePrice;

                var angle = Math.atan((y1 - y2) / SETTING.SLOPE_MIN_COUNT) * 180 / Math.PI;
                data[k].studies.regression.n.angle.push(angle);

                if (data[k].studies.regression.turns.length == 0 || data[k].studies.regression.turns[data[k].studies.regression.turns.length - 1].complete)
                    data[k].studies.regression.turns.push({
                        'complete': false,
                        'start': data[k].range.length - 1,
                        'slopeChange': 0
                    });
                else {
                    var temp = data[k].studies.regression.turns[data[k].studies.regression.turns.length - 1];
                    var lastDiff = angle - data[k].studies.regression.n.angle[data[k].studies.regression.n.angle.length - 2];
                    if ((temp.slopeChange >= 0 && lastDiff >= 0) || (temp.slopeChange <= 0 && lastDiff <= 0))
                        temp.slopeChange += lastDiff;
                    else {
                        temp.complete = true;
                        temp.stop = data[k].range.length - 1;
                        temp.slopeOfChange = 1;

                        var x = 0, xx = 0, y = 0, xy = 0;
                        for (var i = temp.start; i <= temp.stop; i++) {
                            x += (i + 1);
                            xx += (i + 1) * (i + 1);
                            y += data[k].range[i].closePrice;
                            xy += (i + 1) * data[k].range[i].closePrice;
                        }
                        var diff = temp.stop - temp.start + 1;
                        var m = ((diff * xy) - (x * y)) / ((diff * xx) - (x * x));
                        var b = (y - m * x) / diff;

                        var p1 = b; // x = 0, y = mx + b
                        var p2 = m * diff + b; // x = diff

                        // Changed highPrice to previousClosePrice
                        var y1 = SETTING.DISPLAY_NORMALIZE_RATIO * (data[k].limits.previousClosePrice - p1) / data[k].limits.previousClosePrice;
                        var y2 = SETTING.DISPLAY_NORMALIZE_RATIO * (data[k].limits.previousClosePrice - p2) / data[k].limits.previousClosePrice;

                        var angle = Math.atan((y1 - y2) / diff) * 180 / Math.PI;
                        temp.slopeOfChange = angle;
                    }
                }
            }

            return;


            if (data[k].range.length >= SETTING.SLOPE_MIN_COUNT) {
                if (data[k].studies.regression == undefined)
                    data[k].studies.regression = {
                        'slope': [],
                        'intercept': [],
                        'angle': [],
                        'deviation': []
                    };


                //if (data[k].studies.regression.slope.length >= SETTING.SLOPE_DEV_MIN_COUNT) {
                //  var mean = 0;
                //  for (var i = 0; i < SETTING.SLOPE_DEV_MIN_COUNT; i++)
                //      mean += data[k].studies.regression.slope[data[k].studies.regression.slope.length - 1 - i];
                //  mean /= SETTING.SLOPE_DEV_MIN_COUNT;

                //  var variance = 0;
                //  for (var i = 0; i < SETTING.SLOPE_DEV_MIN_COUNT; i++)
                //      variance += (mean - data[k].studies.regression.slope[data[k].studies.regression.slope.length - 1 - i]) * (mean - data[k].studies.regression.slope[data[k].studies.regression.slope.length - 1 - i]);

                var variance = 0;
                for (var i = data[k].range.length - SETTING.SLOPE_MIN_COUNT; i < data[k].range.length; i++) {
                    var diff = (data[k].range[i].closePrice - (m * i + b)) / (m * i + b);
                    variance += diff * diff;
                }
                variance /= SETTING.SLOPE_MIN_COUNT;

                var stdDev = Math.sqrt(variance);
                data[k].studies.regression.deviation.push(stdDev);
                //}
            }
            return;

            var index = data[k].range.length;
            if (index == 0)
                return;

            if (data[k].studies.regression == undefined)
                data[k].studies.regression = {
                    'all': {
                        'slope': [],
                        'intercept': [],
                        'projection': [],
                        'angle': [],
                        'deviation': []
                    },
                    'n': {
                        'slope': [],
                        'intercept': [],
                        'projection': [],
                        'angle': [],
                        'deviation': []
                    },
                    'temp': {
                        'x': 0,
                        'y': 0,
                        'xy': 0,
                        'xx': 0
                    }
                };

            var x = data[k].studies.regression.temp.x += index;
            var y = data[k].studies.regression.temp.y += data[k].range[index - 1].closePrice;
            var xy = data[k].studies.regression.temp.xy += index * data[k].range[index - 1].closePrice;
            var xx = data[k].studies.regression.temp.xx += index * index;

            if (index != 1) {
                var b = ((index * xy) - (x * y)) / ((index * xx) - (x * x));
                var a = (y - b * x) / index;
                var c = a + b * index;

                data[k].studies.regression.slope.push(b);
                data[k].studies.regression.intercept.push(a);
                data[k].studies.regression.projection.push(c);

                var y1 = SETTING.SLOPE_NORMALIZE_RATIO * (data[k].limits.highPrice - a) / data[k].limits.highPrice;
                var y2 = SETTING.SLOPE_NORMALIZE_RATIO * (data[k].limits.highPrice - c) / data[k].limits.highPrice;
                var d = Math.atan((y1 - y2) / index);
                data[k].studies.regression.angle.push(d);

                var variance = 0;
                for (var i = 0; i < index; i++) {
                    var diff = (data[k].range[i].closePrice - (a + b * i)) / (a + b * i);
                    variance += diff * diff;
                }
                variance /= data[k].range.length;
                var stdDev = Math.sqrt(variance);
                data[k].studies.regression.deviation.push(stdDev);
            }

            if (data[k].studies.stoploss == undefined)
                data[k].studies.stoploss = {
                    'price': [data[k].range[0].lowPrice],
                    'trend': [TREND.BULL],
                    'temp': {
                        'G': data[k].range[0].lowPrice,
                        'L': TREND.BULL,
                        'H': data[k].range[0].highPrice,
                        'I': data[k].range[0].highPrice - data[k].range[0].lowPrice,
                        'J': SETTING.PSAR_INCR_ACC_FACTOR,
                        'K': SETTING.PSAR_INCR_ACC_FACTOR * (data[k].range[0].highPrice - data[k].range[0].lowPrice)
                    }
                };

            if (index != 1) {
                var temp = data[k].studies.stoploss.temp;
                var L = data[k].studies.stoploss.trend[data[k].studies.stoploss.trend.length - 1];

                temp.G = (L == TREND.BULL && ((temp.G + temp.K) > data[k].range[index - 1].lowPrice)) || (L == TREND.BEAR && ((temp.G + temp.K) < data[k].range[index - 1].highPrice)) ? temp.H : temp.G + temp.K;
                temp.L = temp.G < data[k].range[index - 1].highPrice ? TREND.BULL : (temp.G > data[k].range[index - 1].lowPrice ? TREND.BEAR : TREND.NONE);
                switch (temp.L) {
                    case TREND.BULL:
                        if (data[k].range[index - 1].highPrice > temp.H) {
                            temp.H = data[k].range[index - 1].highPrice;
                            if (L == temp.L)
                                temp.J = temp.J + SETTING.PSAR_INCR_ACC_FACTOR;
                        }
                        break;
                    case TREND.BEAR:
                        if (data[k].range[index - 1].lowPrice < temp.H) {
                            temp.H = data[k].range[index - 1].lowPrice;
                            if (L == temp.L)
                                temp.J = temp.J + SETTING.PSAR_INCR_ACC_FACTOR;
                        }
                        break;
                }
                if (L != temp.L)
                    temp.J = SETTING.PSAR_INCR_ACC_FACTOR;
                temp.I = temp.H - temp.G;
                temp.K = temp.J * temp.I;

                data[k].studies.stoploss.price.push(temp.G);
                data[k].studies.stoploss.trend.push(temp.L);
            }
        };

        var deferCalculateRange;
        CalculateRange = function () {
            for (var k = 0; k < data.length; k++) {
                var range = {};
                var LTP = undefined;
                while (LTP = data[k].LTP.shift()) {
                    if (range.openPrice == undefined)
                        range.openPrice = LTP;
                    if (range.highPrice == undefined || LTP > range.highPrice)
                        range.highPrice = LTP;
                    if (range.lowPrice == undefined || LTP < range.lowPrice)
                        range.lowPrice = LTP;
                    range.closePrice = LTP;
                }
                if (range.closePrice != undefined) {
                    range.asOf = new Date();
                    data[k].range.push(range);
                    data[k].LTP.unshift(range.closePrice);
                    // 04-05-2015 - for use in UpdateLayout + specific studies calculation
                    // avoids addtl. loop to determine price range
                    if (data[k].limits.highPrice == undefined || range.highPrice > data[k].limits.highPrice)
                        data[k].limits.highPrice = range.highPrice;
                    if (data[k].limits.lowPrice == undefined || range.lowPrice < data[k].limits.lowPrice)
                        data[k].limits.lowPrice = range.lowPrice;
                    CalculateStudies(k);
                }
            }
            EvaluateScrips();
            UpdateLayout();
        };

        var deferCheckIfOpen;
        var state = STATE.CLOSE;
        CheckIfOpen = function () {
            $.ajax({
                url: 'check-market-open.php'.URL(),
                type: 'POST',
                success: function (result) {
                    if (result.error != undefined) {
                        console.error('CheckIfOpen', result.error);
                        deferCheckIfOpen = setTimeout(CheckIfOpen, SETTING.CHECK_OPEN_RETRY_INTERVAL);
                        return;
                    }

                    if (result.state != 0)
                        deferCheckIfOpen = setTimeout(CheckIfOpen, SETTING.CHECK_OPEN_RETRY_INTERVAL);
                    else {
                        // Market is now open, LTP "changes" from Google can now be considered
                        state = STATE.OPEN;

                        deferGetStartState = setTimeout(GetStartState, SETTING.CHECK_START_STATE_INIT_TIMEOUT);
                        deferCalculateRange = setInterval(CalculateRange, SETTING.STUDIES_CALC_INTERVAL);

                        setTimeout(function () {
                            evaluateScrips = true;
                            setTimeout(function () {
                                evaluateScrips = false;
                            }, evaluateScripsEndTime.getTime() - new Date().getTime());
                        }, evaluateScripsStartTime.getTime() - new Date().getTime());

                        setTimeout(function () {
                            state = STATE.CLOSE;
                            clearInterval(deferCalculateRange);
                        }, marketCloseTime.getTime() - new Date().getTime());
                    }
                },
                error: function (HttpRequest, textStatus, errorThrown) {
                    console.error('CheckIfOpen', HttpRequest, textStatus, errorThrown);
                    deferCheckIfOpen = setTimeout(CheckIfOpen, SETTING.CHECK_OPEN_RETRY_INTERVAL);
                }
            });
        };

        SortScrips = function (sortCondition) {
            var tr = $("#quote_container > tr").get();
            tr.sort(function (a, b) {
                try {
                    var a = parseInt(a.id.split('_')[1]);
                    var b = parseInt(b.id.split('_')[1]);

                    switch (sortCondition) {
                        case SORT.SYMBOL_NAME:
                            return data[a].securitySymbol.localeCompare(data[b].securitySymbol);
                        case SORT.LTP_CHANGE:
                            var a = data[a].limits.previousClosePrice == undefined || data[a].range.length == 0 ? 0 : Math.abs((data[a].range[data[a].range.length - 1].closePrice - data[a].limits.previousClosePrice) / data[a].limits.previousClosePrice);
                            var b = data[b].limits.previousClosePrice == undefined || data[b].range.length == 0 ? 0 : Math.abs((data[b].range[data[b].range.length - 1].closePrice - data[b].limits.previousClosePrice) / data[b].limits.previousClosePrice);
                            return b - a;
                        case SORT.NO_OF_TRADES:
                            var a = data[a].BSEState == undefined ? 0 : data[a].BSEState.noOfTrades;
                            var b = data[b].BSEState == undefined ? 0 : data[b].BSEState.noOfTrades;
                            return b - a;
                        case SORT.C2O_CHANGE:
                            var a = data[a].range.length == 0 ? 0 : Math.abs((data[a].range[data[a].range.length - 1].closePrice - data[a].range[0].openPrice) / data[a].range[0].openPrice);
                            var b = data[b].range.length == 0 ? 0 : Math.abs((data[b].range[data[b].range.length - 1].closePrice - data[b].range[0].openPrice) / data[b].range[0].openPrice);
                            return b - a;
                        case SORT.TREND_STRENGTH:
                            var a = data[a].studies.trend.length > 0 == undefined ? 0 : data[a].studies.trend[data[a].studies.trend.length - 1]['ADX'];
                            var b = data[b].studies.trend.length > 0 == undefined ? 0 : data[b].studies.trend[data[b].studies.trend.length - 1]['ADX'];
                            return b - a;
                        case SORT.SLOPE_ANGLE:
                            var a = data[a].studies.regression == undefined || data[a].studies.regression.all.angle.length == 0 ? 0 : Math.abs(data[a].studies.regression.all.angle[data[a].studies.regression.all.angle.length - 1]);
                            var b = data[b].studies.regression == undefined || data[b].studies.regression.all.angle.length == 0 ? 0 : Math.abs(data[b].studies.regression.all.angle[data[b].studies.regression.all.angle.length - 1]);
                            return b - a;
                    }
                }
                catch (e) {
                    return 0;
                }
            });
            for (var i = 0; i < tr.length; i++)
                tr[i].parentNode.appendChild(tr[i]);
        };

        var google;
        BeginGoogle = function () {
            // URL is subject to browser & OS
            google = window.open('https://www.google.com/intl/en/about/#SAFE', 'WND-GOOGLE-HOME');
        };

        var religare;
        BeginReligare = function () {
            window.open('https://secure.religareonline.com/Login.aspx?rdrURL=https%3A//secure.religareonline.com/OrderBook.aspx%3Fassettype%3DEquity', 'WND-RELIGARE-ORDER');
        };

        DoSomething = function () {
            try {
                $.getJSON('data.json', function (data) {
                    window.data = data;
                    for (var k = 0; k < data.length; k++) {
                        data[k].k = k;
                        data[k].LTP = [];
                        data[k].range = [];
                        data[k].studies = {};
                        data[k].limits = {};
                        // add k to dataPendingStartState; processing will start only later (once CheckIfOpen passes)
                        dataPendingStartState.push(k);
                    }
                    // Set-up the initial table layout
                    UpdateLayout();
                    // In case, execution time post marketSpeculativeOpenTime, immediately executed (setTimeout doesn't recognize -ve times)
                    deferCheckIfOpen = setTimeout(CheckIfOpen, marketSpeculativeOpenTime.getTime() - new Date().getTime());
                });
            }
            catch (e) {
                // In the unlikely event that jquery is not loaded before this function is executed
                setTimeout(DoSomething, SETTING.DO_SOMETHING_RETRY_INTERVAL);
            }
        };

        window.addEventListener('message', ProcessMessage, false);

        window.onbeforeunload = function () {
            return 'You might have open positions.';
        };

        DoSomething();
    </script>

    <div id="header" style="padding-right: 8px"></div>

    <div style="position: absolute; display: block; right: 0px;">
        <table style="padding-right: 8px;">
            <tr>
                <td class="no-border" style="text-align: right">
                    <a href="javascript:BeginGoogle()">
                        Google:&nbsp;
                    </a>
                </td>
                <td id="state_google" class="no-border" style="color: #D14836;">
                    OFF
                </td>
            </tr>
            <tr>
                <td class="no-border" style="text-align: right">
                    <a href="javascript:BeginReligare()">
                        Religare:&nbsp;
                    </a>
                </td>
                <td id="state_religare" class="no-border" style="color: #D14836;">
                    OFF
                </td>
            </tr>
        </table>
    </div>

    <div style="float: left; padding-right: 8px">
        <table style="border-color: black; border-top: 1px solid #C8EFEA; border-left: 1px solid #C8EFEA; margin: 0px; padding: 0px" border="0" cellspacing="0" cellpadding="2">
            <thead>
                <tr>
                    <th id="scrip_top" class="sort" style="width: 90px;" rowspan="2">Scrip</th>
                    <th id="ltp_top" class="sort" style="width: 55px;">LTP<br />%Chg</th>
                    <th style="width: 200px;">Chart</th>
                    <th id="trades_top" class="sort" style="width: 55px;">No. of<br />trades</th>
                    <th id="ohlc_top" class="sort" style="width: 55px;">C to O<br />H to L</th>
                    <th style="width: 200px;">Trend</th>
                    <th id="adx_top" class="sort" style="width: 85px;">ADX<br />+DI / -DI</th>
                    <th style="width: 200px;">Slope</th>
                    <th id="angle_top" class="sort" style="width: 55px;">&theta;<br />&sigma;</th>
                </tr>
            </thead>
            <tbody id="quote_container" style="text-align: right">
                <tr id="quote_no_rows">
                    <td colspan="9" style="text-align: center">
                        -
                    </td>
                </tr>
            </tbody>
        </table>
        <div>
            <img src="buy.png" id="buy" alt="buy" style="vertical-align:middle"> &amp; <img src="sell.png" id="sell" alt="sell" style="vertical-align:middle"> indicate buy &amp; sell trades resp.              
        </div>
    </div>

    <div id="metrics" style="position: fixed; left: 15px; top: 10px; width: 100px; padding: 2px; border: 1px solid #C8EFEA; color: #1C355D; background-color: #F8F8E4; visibility: hidden;">
        <span></span>
        <img src="close.png" onclick="HideMetrics()" alt="close" style="position: absolute; right: -8px; top: -8px;">
    </div>

    <div id="pointer" style="position: absolute; border-right: 1px solid #FF7F00; width: 0px; height: 0px; visibility: hidden;">
    </div>

    <script>
        $('th#scrip_top').click(function () {
            SortScrips(SORT.SYMBOL_NAME);
        });
        $('th#ltp_top').click(function () {
            SortScrips(SORT.LTP_CHANGE);
        });
        $('th#trades_top').click(function () {
            SortScrips(SORT.NO_OF_TRADES);
        });
        $('th#ohlc_top').click(function () {
            SortScrips(SORT.C2O_CHANGE);
        });
        $('th#adx_top').click(function () {
            SortScrips(SORT.TREND_STRENGTH);
        });
        $('th#angle_top').click(function () {
            SortScrips(SORT.SLOPE_ANGLE);
        });
    </script>
</body>

</html>
